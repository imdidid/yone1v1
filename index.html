<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Yone 1v1 Simulator</title>
  <style>
    body {
      margin: 0;
      background: #0d0d11;
      color: #f0f0f0;
      font-family: "Segoe UI", Tahoma, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
    }
    header {
      padding: 12px 0;
      text-align: center;
    }
    #hud {
      display: flex;
      gap: 32px;
      margin-bottom: 8px;
      font-size: 14px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .hud-block {
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.07);
      border-radius: 8px;
      min-width: 180px;
    }
    canvas {
      border: 2px solid #1f2738;
      background: radial-gradient(circle at center, #1e2434 0%, #101320 70%);
      max-width: 100%;
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.45);
    }
    #log {
      width: min(960px, 100%);
      height: 120px;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 8px;
      margin: 12px 0;
      padding: 8px 12px;
      font-size: 12px;
      line-height: 1.4;
      white-space: pre-wrap;
    }
    #controls {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      padding: 8px 16px;
      background: #2c3e55;
      border: none;
      color: #fff;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover {
      background: #3f5575;
    }
    button:active {
      background: #243346;
    }
  </style>
</head>
<body>
  <header>
    <h1>Yone 1v1 2D Simulator</h1>
  </header>
  <section id="hud"></section>
  <canvas id="game"></canvas>
  <div id="log"></div>
  <div id="controls">
    <button id="btn-reset">Reset</button>
    <button id="btn-toggle-train">Toggle Training</button>
    <button id="btn-clear-q">Clear Q-Table</button>
  </div>
  <script>
    const BASE = { W: 1600, H: 900 };
    const VIEW = { W: 1600, H: 900 };
    const STEP = 1 / 60;

    const CONST = {
      MS: 345,
      AA_RANGE: 175,
      AS_BASE: 1.0,
      WINDUP: 0.22,
      Q12_CAST: 0.23,
      Q3_CAST: 0.23,
      Q12_CD: 2.5,
      W_CD: 8.8,
      FLASH_RANGE: 425,
      FLASH_CD: 300,
      Q3_TORNADO_SPEED: 1500,
      Q3_TORNADO_RANGE: 1050,
      Q3_DASH_SPEED: 1200,
      Q3_BODY_R: 120,
      Q3_AIR: 0.75,
      LT_MAX: 6,
      LT_PER: 0.06,
      LT_DUR: 6.0,
      DMG_AA: 20,
      DMG_Q12: 25,
      DMG_Q3_T: 10,
      DMG_Q3_B: 15,
      W_SHIELD: 10,
      W_DMG: 10
    };

    const CC = { NONE: 0, AIR: 1 << 0, STUN: 1 << 1 };
    const AA = { IDLE: 0, WIND: 1, BACK: 2 };
    const QP = { IDLE: 0, Q12W: 1, Q3W: 2, Q3D: 3, DONE: 4 };

    let S = 1;
    const D = {};

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function clampPos(p) {
      return {
        x: clamp(p.x, 0, VIEW.W),
        y: clamp(p.y, 0, VIEW.H)
      };
    }

    function dist(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function dot(a, b) {
      return a.x * b.x + a.y * b.y;
    }

    function norm(v) {
      const len = Math.hypot(v.x, v.y);
      if (!len) return { x: 1, y: 0 };
      return { x: v.x / len, y: v.y / len };
    }

    function faceFromTo(from, to) {
      return norm({ x: to.x - from.x, y: to.y - from.y });
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function applyScale() {
      S = Math.min(VIEW.W / BASE.W, VIEW.H / BASE.H);
      D.MS = CONST.MS * S;
      D.AA_RANGE = CONST.AA_RANGE * S;
      D.FLASH_RANGE = CONST.FLASH_RANGE * S;
      D.Q3_TORNADO_SPEED = CONST.Q3_TORNADO_SPEED * S;
      D.Q3_TORNADO_RANGE = CONST.Q3_TORNADO_RANGE * S;
      D.Q3_DASH_SPEED = CONST.Q3_DASH_SPEED * S;
      D.Q3_BODY_R = CONST.Q3_BODY_R * S;
      D.W_RANGE = 250 * S;
      D.Q12_RANGE = 450 * S;
      D.TORNADO_RADIUS = 12 * S;
    }

    class Tornado {
      constructor(owner) {
        this.owner = owner;
        this.active = false;
        this.x = 0;
        this.y = 0;
        this.dir = { x: 1, y: 0 };
        this.travel = 0;
      }

      spawn(pos, dir) {
        this.active = true;
        this.x = pos.x;
        this.y = pos.y;
        this.dir = { x: dir.x, y: dir.y };
        this.travel = 0;
      }

      update(t, dt, enemy) {
        if (!this.active) return;
        const step = D.Q3_TORNADO_SPEED * dt;
        this.x += this.dir.x * step;
        this.y += this.dir.y * step;
        this.travel += step;
        if (this.travel >= D.Q3_TORNADO_RANGE) {
          this.active = false;
          return;
        }
        if (dist(this, enemy) <= D.TORNADO_RADIUS) {
          enemy.air(t, CONST.Q3_AIR);
          enemy.hit(CONST.DMG_Q3_T);
          this.active = false;
          this.owner.agent?.registerHit('Q3_TORNADO');
        }
      }

      draw(ctx) {
        if (!this.active) return;
        ctx.save();
        ctx.translate(this.x, this.y);
        const grd = ctx.createRadialGradient(0, 0, 0, 0, 0, 24 * S);
        grd.addColorStop(0, 'rgba(130,220,255,0.8)');
        grd.addColorStop(1, 'rgba(0,128,255,0)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(0, 0, 24 * S, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    class Player {
      constructor(opts) {
        this.name = opts.name;
        this.color = opts.color;
        this.agent = opts.agent || null;
        this.spawn = { x: opts.x, y: opts.y };
        this.reset();
      }

      reset() {
        this.x = this.spawn.x;
        this.y = this.spawn.y;
        this.face = { x: 1, y: 0 };
        this.hp = 100;
        this.shield = 0;
        this.cdQ = 0;
        this.cdW = 0;
        this.cdE = 0;
        this.cdR = 0;
        this.cdF = 0;
        this.lt = 0;
        this.ltT = 0;
        this.mouse = { x: this.x, y: this.y };
        this.move = null;
        this.queue = null;
        this.aa = AA.IDLE;
        this.aaS = this.aaF = this.aaE = this.nextAA = 0;
        this.lock = false;
        this.lockEnd = 0;
        this.casting = null;
        this.qStacks = 0;
        this.qP = QP.IDLE;
        this.qDir = { x: 1, y: 0 };
        this.q3End = 0;
        this.q3Body = false;
        this.torn = new Tornado(this);
        this.cc = CC.NONE;
        this.ccUntil = 0;
        this.prevDamageTaken = 0;
      }

      get pos() {
        return { x: this.x, y: this.y };
      }

      beginTick() {
        this.prevDamageTaken = 0;
      }

      readyQ(t) {
        return t >= this.cdQ;
      }

      readyW(t) {
        return t >= this.cdW;
      }

      readyF(t) {
        return t >= this.cdF;
      }

      tryAA(t, enemy) {
        if (this.cc !== CC.NONE || this.lock) return false;
        if (this.aa !== AA.IDLE) return false;
        if (t < this.nextAA) return false;
        if (dist(this, enemy) > D.AA_RANGE) return false;
        this.face = faceFromTo(this, enemy);
        this.aa = AA.WIND;
        this.aaS = t;
        const atkPerSec = CONST.AS_BASE * (1 + this.lt * CONST.LT_PER);
        const period = 1 / atkPerSec;
        this.aaF = t + CONST.WINDUP * period;
        this.aaE = t + period;
        return true;
      }

      cancelAA() {
        if (this.aa === AA.WIND) {
          this.aa = AA.IDLE;
          this.aaS = this.aaF = this.aaE = 0;
        }
      }

      castQ(t, enemy) {
        if (!this.readyQ(t) || this.lock || this.cc !== CC.NONE) return false;
        this.cancelAA();
        this.face = faceFromTo(this, this.mouse);
        this.qDir = { x: this.face.x, y: this.face.y };
        this.lock = true;
        if (this.qStacks >= 2) {
          this.casting = 'Q3';
          this.qP = QP.Q3W;
          this.lockEnd = t + CONST.Q3_CAST;
          this.qStacks = 0;
        } else {
          this.casting = 'Q12';
          this.qP = QP.Q12W;
          this.lockEnd = t + CONST.Q12_CAST;
        }
        return true;
      }

      castW(t) {
        if (!this.readyW(t) || this.lock || this.cc !== CC.NONE) return false;
        this.cancelAA();
        this.face = faceFromTo(this, this.mouse);
        this.casting = 'W';
        this.lock = true;
        this.lockEnd = t + 0.30;
        return true;
      }

      castF(t, enemy) {
        if (!this.readyF(t) || this.cc !== CC.NONE) return false;
        const dir = faceFromTo(this, this.mouse);
        const distToMouse = dist(this, this.mouse);
        const step = Math.min(distToMouse, D.FLASH_RANGE);
        this.x += dir.x * step;
        this.y += dir.y * step;
        const clamped = clampPos(this);
        this.x = clamped.x;
        this.y = clamped.y;
        this.mouse = { x: this.x + dir.x * 10, y: this.y + dir.y * 10 };
        this.face = { ...dir };
        this.cdF = t + CONST.FLASH_CD;
        this.cancelAA();
        if (this.lock) {
          if (this.casting === 'Q12' || this.casting === 'Q3' || this.casting === 'W') {
            // position already updated; direction remains
          }
        }
        if (this.qP === QP.Q3D && this.q3Body) {
          this.qP = QP.DONE;
          this.q3Body = false;
          const distance = dist(this, enemy);
          if (distance <= D.Q3_BODY_R) {
            enemy.air(t, CONST.Q3_AIR);
            enemy.hit(CONST.DMG_Q3_B);
            this.agent?.registerHit('Q3_FLASH');
          }
        }
        return true;
      }

      onCastEnd(t, enemy) {
        this.lock = false;
        const cast = this.casting;
        this.casting = null;
        if (cast === 'Q12') {
          this.cdQ = t + CONST.Q12_CD;
          if (this.cc !== CC.NONE) {
            this.qP = QP.DONE;
            this.agent?.registerMiss();
          } else {
            const rel = { x: enemy.x - this.x, y: enemy.y - this.y };
            const proj = dot(rel, this.qDir);
            if (proj >= 0 && proj <= D.Q12_RANGE) {
              enemy.hit(CONST.DMG_Q12);
              this.qStacks = Math.min(2, this.qStacks + 1);
              this.agent?.registerHit('Q12');
            } else {
              this.agent?.registerMiss();
            }
            this.qP = QP.DONE;
          }
        } else if (cast === 'Q3') {
          this.cdQ = t + CONST.Q12_CD;
          this.qP = QP.Q3D;
          this.q3Body = true;
          this.q3End = t + (D.Q3_TORNADO_RANGE / D.Q3_DASH_SPEED);
          this.torn.spawn(this.pos, this.qDir);
        } else if (cast === 'W') {
          this.cdW = t + CONST.W_CD;
          const rel = { x: enemy.x - this.x, y: enemy.y - this.y };
          const proj = dot(rel, this.face);
          if (proj >= 0 && proj <= D.W_RANGE) {
            enemy.hit(CONST.W_DMG);
            this.shield += CONST.W_SHIELD;
            this.agent?.registerHit('W');
          } else {
            this.agent?.registerMiss();
          }
        }
        if (this.queue) {
          this.move = this.queue;
          this.queue = null;
        }
      }

      updateQ3(t, dt, enemy) {
        this.torn.update(t, dt, enemy);
        if (this.qP !== QP.Q3D || !this.q3Body) return;
        const step = D.Q3_DASH_SPEED * dt;
        this.x += this.qDir.x * step;
        this.y += this.qDir.y * step;
        const clamped = clampPos(this);
        this.x = clamped.x;
        this.y = clamped.y;
        if (dist(this, enemy) <= D.Q3_BODY_R) {
          enemy.air(t, CONST.Q3_AIR);
          enemy.hit(CONST.DMG_Q3_B);
          this.q3Body = false;
          this.qP = QP.DONE;
          this.agent?.registerHit('Q3_BODY');
        }
        if (t >= this.q3End) {
          this.qP = QP.DONE;
          this.q3Body = false;
        }
      }

      air(t, dur) {
        this.cc = this.cc | CC.AIR;
        this.ccUntil = Math.max(this.ccUntil, t + dur);
        this.lock = false;
        this.casting = null;
        this.qP = QP.DONE;
        this.q3Body = false;
        this.aa = AA.IDLE;
      }

      hit(dmg) {
        let remain = dmg;
        if (this.shield > 0) {
          const taken = Math.min(this.shield, remain);
          this.shield -= taken;
          remain -= taken;
        }
        if (remain > 0) {
          this.hp = Math.max(0, this.hp - remain);
        }
        this.prevDamageTaken += dmg;
      }

      moveTick(dt) {
        if (this.cc !== CC.NONE || this.lock) {
          if (this.move) {
            this.queue = this.move;
            this.move = null;
          }
          return;
        }
        if (!this.move) return;
        const dest = clampPos(this.move);
        this.move = dest;
        const direction = faceFromTo(this, dest);
        const speed = D.MS;
        const step = speed * dt;
        const d = dist(this, dest);
        if (d <= step) {
          this.x = dest.x;
          this.y = dest.y;
          this.move = null;
        } else {
          this.x += direction.x * step;
          this.y += direction.y * step;
        }
        this.face = direction;
      }

      updCC(t) {
        if (this.cc !== CC.NONE && t >= this.ccUntil) {
          this.cc = CC.NONE;
        }
      }

      tick(dt) {
        if (this.lt > 0) {
          this.ltT -= dt;
          if (this.ltT <= 0) {
            this.lt = 0;
            this.ltT = 0;
          }
        }
      }

      resolveAA(t, enemy) {
        if (this.aa === AA.WIND && t >= this.aaF) {
          this.aa = AA.BACK;
          enemy.hit(CONST.DMG_AA);
          this.lt = Math.min(CONST.LT_MAX, this.lt + 1);
          this.ltT = CONST.LT_DUR;
          this.agent?.registerHit('AA');
        }
        if (this.aa === AA.BACK && t >= this.aaE) {
          this.aa = AA.IDLE;
          this.nextAA = this.aaE;
        }
      }
    }

    class EpisodeStats {
      constructor() {
        this.reset();
      }
      reset() {
        this.ticks = 0;
        this.duration = 0;
        this.events = [];
      }
      addEvent(msg) {
        this.events.push(`[${simTime.toFixed(2)}] ${msg}`);
        if (this.events.length > 50) this.events.shift();
      }
    }

    class QTableStore {
      constructor() {
        this.key = 'yone_q_table_v1';
        this.data = {};
        this.load();
      }
      load() {
        try {
          const raw = localStorage.getItem(this.key);
          if (raw) {
            this.data = JSON.parse(raw);
          }
        } catch (e) {
          console.warn('Failed to load Q-table', e);
        }
      }
      save() {
        try {
          localStorage.setItem(this.key, JSON.stringify(this.data));
        } catch (e) {
          console.warn('Failed to save Q-table', e);
        }
      }
      clear() {
        this.data = {};
        this.save();
      }
      get(state) {
        if (!this.data[state]) {
          this.data[state] = [0, 0, 0, 0, 0, 0, 0];
        }
        return this.data[state];
      }
    }

    const ACTIONS = ['STOP', 'APPROACH', 'RETREAT', 'AA', 'Q', 'W', 'FLASH'];

    class RLAgent {
      constructor(name, enemyGetter) {
        this.name = name;
        this.enemyGetter = enemyGetter;
        this.table = sharedQTable;
        this.epsilon = 0.1;
        this.alpha = 0.1;
        this.gamma = 0.95;
        this.lastState = null;
        this.lastAction = null;
        this.training = true;
        this.rewardBuffer = 0;
        this.hitFlag = 0;
        this.missFlag = 0;
      }

      toggleTraining() {
        this.training = !this.training;
      }

      getState(self, enemy) {
        const d = dist(self, enemy) / (S * 800);
        let bucket = 4;
        if (d < 0.15) bucket = 0;
        else if (d < 0.30) bucket = 1;
        else if (d < 0.45) bucket = 2;
        else if (d < 0.60) bucket = 3;
        const qReady = self.readyQ(simTime) ? 1 : 0;
        const wReady = self.readyW(simTime) ? 1 : 0;
        const fReady = self.readyF(simTime) ? 1 : 0;
        const qs = self.qStacks;
        const air = enemy.cc & CC.AIR ? 1 : 0;
        return `d${bucket}_Q${qReady}_W${wReady}_F${fReady}_qs${qs}_air${air}`;
      }

      decide(self, enemy) {
        const state = this.getState(self, enemy);
        const qValues = this.table.get(state);
        let actionIndex;
        if (this.training && Math.random() < this.epsilon) {
          actionIndex = Math.floor(Math.random() * ACTIONS.length);
        } else {
          let maxQ = -Infinity;
          actionIndex = 0;
          for (let i = 0; i < qValues.length; i++) {
            if (qValues[i] > maxQ) {
              maxQ = qValues[i];
              actionIndex = i;
            }
          }
        }
        this.executeAction(actionIndex, self, enemy);
        this.lastState = state;
        this.lastAction = actionIndex;
        return actionIndex;
      }

      executeAction(idx, self, enemy) {
        const action = ACTIONS[idx];
        switch (action) {
          case 'STOP':
            self.move = null;
            break;
          case 'APPROACH':
            self.move = { x: enemy.x, y: enemy.y };
            break;
          case 'RETREAT': {
            const dir = norm({ x: self.x - enemy.x, y: self.y - enemy.y });
            const target = {
              x: self.x + dir.x * 300 * S,
              y: self.y + dir.y * 300 * S
            };
            self.move = clampPos(target);
            break;
          }
          case 'AA':
            self.tryAA(simTime, enemy);
            break;
          case 'Q':
            self.mouse = { x: enemy.x, y: enemy.y };
            self.castQ(simTime, enemy);
            break;
          case 'W':
            self.mouse = { x: enemy.x, y: enemy.y };
            self.castW(simTime);
            break;
          case 'FLASH': {
            self.mouse = { x: enemy.x, y: enemy.y };
            self.castF(simTime, enemy);
            break;
          }
        }
      }

      registerHit(skill) {
        this.hitFlag += 1;
      }

      registerMiss() {
        this.missFlag += 1;
      }

      onTickEnd(self, enemy) {
        if (!this.training || this.lastState === null || this.lastAction === null) {
          this.rewardBuffer = 0;
          this.hitFlag = 0;
          this.missFlag = 0;
          if (!this.training) {
            this.lastState = null;
            this.lastAction = null;
          }
          return;
        }
        const reward = this.computeReward(self, enemy);
        const nextState = this.getState(self, enemy);
        const qValues = this.table.get(this.lastState);
        const nextQ = this.table.get(nextState);
        const maxNext = Math.max(...nextQ);
        const old = qValues[this.lastAction];
        const updated = lerp(old, reward + this.gamma * maxNext, this.alpha);
        qValues[this.lastAction] = updated;
        this.table.data[this.lastState] = qValues;
        this.rewardBuffer = 0;
        this.hitFlag = 0;
        this.missFlag = 0;
        this.lastState = nextState;
        this.lastAction = null;
      }

      computeReward(self, enemy) {
        const enemyDamage = enemy.prevDamageTaken;
        const selfDamage = self.prevDamageTaken;
        let reward = (enemyDamage - selfDamage) * 0.05;
        if (this.hitFlag > 0) reward += 0.02 * this.hitFlag;
        if (this.missFlag > 0) reward -= 0.01 * this.missFlag;
        return reward;
      }

      terminalReward(value) {
        if (!this.training || this.lastState === null || this.lastAction === null) {
          this.lastState = null;
          this.lastAction = null;
          return;
        }
        const qValues = this.table.get(this.lastState);
        const old = qValues[this.lastAction];
        const updated = lerp(old, value, this.alpha);
        qValues[this.lastAction] = updated;
        this.table.data[this.lastState] = qValues;
        this.lastState = null;
        this.lastAction = null;
        this.hitFlag = 0;
        this.missFlag = 0;
      }
    }

    class DummyAgent {
      constructor(name) {
        this.name = name;
      }
      decide(self, enemy) {
        self.mouse = { x: enemy.x, y: enemy.y };
        if (dist(self, enemy) > D.AA_RANGE * 0.8) {
          self.move = { x: enemy.x, y: enemy.y };
        } else {
          self.move = null;
        }
        self.tryAA(simTime, enemy);
        if (self.readyQ(simTime)) self.castQ(simTime, enemy);
        if (self.readyW(simTime)) self.castW(simTime);
      }
      onTickEnd() {}
    }

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const hud = document.getElementById('hud');
    const logPanel = document.getElementById('log');
    const btnReset = document.getElementById('btn-reset');
    const btnToggle = document.getElementById('btn-toggle-train');
    const btnClear = document.getElementById('btn-clear-q');

    const sharedQTable = new QTableStore();

    let simTime = 0;
    let episodeId = 0;
    let episodeStats = new EpisodeStats();

    function resizeCanvas() {
      const ratio = BASE.W / BASE.H;
      const width = Math.min(window.innerWidth - 40, 1100);
      const height = width / ratio;
      canvas.width = width;
      canvas.height = height;
      VIEW.W = width;
      VIEW.H = height;
    }

    const agents = [];
    let player1, player2;

    function createPlayers() {
      const agent1 = new RLAgent('Yone A');
      const agent2 = new RLAgent('Yone B');
      agent1.enemyGetter = () => player2;
      agent2.enemyGetter = () => player1;
      agents[0] = agent1;
      agents[1] = agent2;
      player1 = new Player({
        name: 'Yone A',
        color: 'rgba(255,80,80,0.9)',
        x: canvas.width * 0.25,
        y: canvas.height * 0.5,
        agent: agent1
      });
      player2 = new Player({
        name: 'Yone B',
        color: 'rgba(80,160,255,0.9)',
        x: canvas.width * 0.75,
        y: canvas.height * 0.5,
        agent: agent2
      });
    }

    function resetPlayers() {
      player1.reset();
      player2.reset();
      player1.x = canvas.width * 0.25;
      player1.y = canvas.height * 0.5;
      player2.x = canvas.width * 0.75;
      player2.y = canvas.height * 0.5;
      player1.face = { x: 1, y: 0 };
      player2.face = { x: -1, y: 0 };
      simTime = 0;
      episodeStats.reset();
      episodeId += 1;
      agents.forEach((agent) => {
        if (agent) {
          if ('lastState' in agent) agent.lastState = null;
          if ('lastAction' in agent) agent.lastAction = null;
        }
      });
    }

    function updateHUD() {
      const blocks = [player1, player2].map((p) => {
        const cooldown = (cd) => Math.max(0, cd - simTime).toFixed(2);
        return `
          <div class="hud-block">
            <strong>${p.name}</strong><br />
            HP: ${p.hp.toFixed(1)} | SH: ${p.shield.toFixed(1)}<br />
            LT: ${p.lt} (${p.ltT.toFixed(1)}s)<br />
            Q:${cooldown(p.cdQ)} W:${cooldown(p.cdW)} F:${cooldown(p.cdF)}<br />
            qStacks: ${p.qStacks} | CC: ${p.cc}
          </div>
        `;
      });
      hud.innerHTML = blocks.join('');
    }

    function drawPlayer(p) {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(0, 0, 20 * S, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(p.face.x * 28 * S, p.face.y * 28 * S);
      ctx.stroke();
      if (p.shield > 0) {
        ctx.strokeStyle = 'rgba(120,220,255,0.7)';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0, 0, 24 * S, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawHUD() {
      updateHUD();
    }

    function drawBackground() {
      ctx.save();
      ctx.fillStyle = '#121623';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      for (let x = 0; x <= canvas.width; x += 100 * S) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += 100 * S) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function log(msg) {
      episodeStats.addEvent(msg);
      logPanel.textContent = episodeStats.events.join('\n');
      logPanel.scrollTop = logPanel.scrollHeight;
    }

    function aiDecision() {
      player1.agent.decide(player1, player2);
      player2.agent.decide(player2, player1);
    }

    function movement(dt) {
      player1.moveTick(dt);
      player2.moveTick(dt);
    }

    function castEnd() {
      if (player1.lock && simTime >= player1.lockEnd) {
        player1.onCastEnd(simTime, player2);
      }
      if (player2.lock && simTime >= player2.lockEnd) {
        player2.onCastEnd(simTime, player1);
      }
    }

    function updateQ3(dt) {
      player1.updateQ3(simTime, dt, player2);
      player2.updateQ3(simTime, dt, player1);
    }

    function resolveAA() {
      player1.resolveAA(simTime, player2);
      player2.resolveAA(simTime, player1);
    }

    function updateStates(dt) {
      player1.tick(dt);
      player2.tick(dt);
      player1.updCC(simTime);
      player2.updCC(simTime);
    }

    function checkEnd() {
      if (player1.hp <= 0 || player2.hp <= 0) {
        let message = 'Draw';
        let reward1 = 0;
        let reward2 = 0;
        if (player1.hp > player2.hp) {
          message = `${player1.name} wins!`;
          reward1 = 1;
          reward2 = -1;
        } else if (player2.hp > player1.hp) {
          message = `${player2.name} wins!`;
          reward1 = -1;
          reward2 = 1;
        }
        log(message);
        player1.agent?.terminalReward(reward1);
        player2.agent?.terminalReward(reward2);
        sharedQTable.save();
        resetPlayers();
      }
    }

    function tick() {
      player1.beginTick();
      player2.beginTick();
      aiDecision();
      movement(STEP);
      castEnd();
      updateQ3(STEP);
      resolveAA();
      updateStates(STEP);
      player1.agent.onTickEnd(player1, player2);
      player2.agent.onTickEnd(player2, player1);
      checkEnd();
      simTime += STEP;
      episodeStats.ticks += 1;
      episodeStats.duration += STEP;
    }

    function render() {
      drawBackground();
      player1.torn.draw(ctx);
      player2.torn.draw(ctx);
      drawPlayer(player1);
      drawPlayer(player2);
      drawHUD();
    }

    function loop() {
      tick();
      render();
      requestAnimationFrame(loop);
    }

    function init() {
      resizeCanvas();
      applyScale();
      createPlayers();
      resetPlayers();
      render();
      requestAnimationFrame(loop);
    }

    window.addEventListener('resize', () => {
      resizeCanvas();
      applyScale();
    });

    btnReset.addEventListener('click', () => {
      resetPlayers();
      log('Manual reset');
    });

    btnToggle.addEventListener('click', () => {
      agents.forEach((agent) => {
        if (agent.toggleTraining) agent.toggleTraining();
      });
      const state = agents[0].training ? 'ON' : 'OFF';
      log(`Training toggled ${state}`);
    });

    btnClear.addEventListener('click', () => {
      sharedQTable.clear();
      log('Cleared Q-table');
    });

    init();
  </script>
</body>
</html>
